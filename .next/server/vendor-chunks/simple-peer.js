/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-peer";
exports.ids = ["vendor-chunks/simple-peer"];
exports.modules = {

/***/ "(ssr)/./node_modules/simple-peer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/simple-peer/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ const debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"simple-peer\");\nconst getBrowserRTC = __webpack_require__(/*! get-browser-rtc */ \"(ssr)/./node_modules/get-browser-rtc/index.js\");\nconst randombytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/randombytes/index.js\");\nconst stream = __webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\");\nconst queueMicrotask = __webpack_require__(/*! queue-microtask */ \"(ssr)/./node_modules/queue-microtask/index.js\") // TODO: remove when Node 10 is not supported\n;\nconst errCode = __webpack_require__(/*! err-code */ \"(ssr)/./node_modules/err-code/index.js\");\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst MAX_BUFFERED_AMOUNT = 64 * 1024;\nconst ICECOMPLETE_TIMEOUT = 5 * 1000;\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000;\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle(sdp) {\n    return sdp.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction warn(message) {\n    console.warn(message);\n}\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */ class Peer extends stream.Duplex {\n    constructor(opts){\n        opts = Object.assign({\n            allowHalfOpen: false\n        }, opts);\n        super(opts);\n        this._id = randombytes(4).toString(\"hex\").slice(0, 7);\n        this._debug(\"new peer %o\", opts);\n        this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString(\"hex\") : null;\n        this.initiator = opts.initiator || false;\n        this.channelConfig = opts.channelConfig || Peer.channelConfig;\n        this.channelNegotiated = this.channelConfig.negotiated;\n        this.config = Object.assign({}, Peer.config, opts.config);\n        this.offerOptions = opts.offerOptions || {};\n        this.answerOptions = opts.answerOptions || {};\n        this.sdpTransform = opts.sdpTransform || ((sdp)=>sdp);\n        this.streams = opts.streams || (opts.stream ? [\n            opts.stream\n        ] : [] // support old \"stream\" option\n        );\n        this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n        this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;\n        this.destroyed = false;\n        this.destroying = false;\n        this._connected = false;\n        this.remoteAddress = undefined;\n        this.remoteFamily = undefined;\n        this.remotePort = undefined;\n        this.localAddress = undefined;\n        this.localFamily = undefined;\n        this.localPort = undefined;\n        this._wrtc = opts.wrtc && typeof opts.wrtc === \"object\" ? opts.wrtc : getBrowserRTC();\n        if (!this._wrtc) {\n            if (true) {\n                throw errCode(new Error(\"No WebRTC support: Specify `opts.wrtc` option in this environment\"), \"ERR_WEBRTC_SUPPORT\");\n            } else {}\n        }\n        this._pcReady = false;\n        this._channelReady = false;\n        this._iceComplete = false // ice candidate trickle done (got null candidate)\n        ;\n        this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n        ;\n        this._channel = null;\n        this._pendingCandidates = [];\n        this._isNegotiating = false // is this peer waiting for negotiation to complete?\n        ;\n        this._firstNegotiation = true;\n        this._batchedNegotiation = false // batch synchronous negotiations\n        ;\n        this._queuedNegotiation = false // is there a queued negotiation request?\n        ;\n        this._sendersAwaitingStable = [];\n        this._senderMap = new Map();\n        this._closingInterval = null;\n        this._remoteTracks = [];\n        this._remoteStreams = [];\n        this._chunk = null;\n        this._cb = null;\n        this._interval = null;\n        try {\n            this._pc = new this._wrtc.RTCPeerConnection(this.config);\n        } catch (err) {\n            this.destroy(errCode(err, \"ERR_PC_CONSTRUCTOR\"));\n            return;\n        }\n        // We prefer feature detection whenever possible, but sometimes that's not\n        // possible for certain implementations.\n        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === \"number\";\n        this._pc.oniceconnectionstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onicegatheringstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onconnectionstatechange = ()=>{\n            this._onConnectionStateChange();\n        };\n        this._pc.onsignalingstatechange = ()=>{\n            this._onSignalingStateChange();\n        };\n        this._pc.onicecandidate = (event)=>{\n            this._onIceCandidate(event);\n        };\n        // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n        if (typeof this._pc.peerIdentity === \"object\") {\n            this._pc.peerIdentity.catch((err)=>{\n                this.destroy(errCode(err, \"ERR_PC_PEER_IDENTITY\"));\n            });\n        }\n        // Other spec events, unused by this implementation:\n        // - onconnectionstatechange\n        // - onicecandidateerror\n        // - onfingerprintfailure\n        // - onnegotiationneeded\n        if (this.initiator || this.channelNegotiated) {\n            this._setupData({\n                channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n            });\n        } else {\n            this._pc.ondatachannel = (event)=>{\n                this._setupData(event);\n            };\n        }\n        if (this.streams) {\n            this.streams.forEach((stream)=>{\n                this.addStream(stream);\n            });\n        }\n        this._pc.ontrack = (event)=>{\n            this._onTrack(event);\n        };\n        this._debug(\"initial negotiation\");\n        this._needsNegotiation();\n        this._onFinishBound = ()=>{\n            this._onFinish();\n        };\n        this.once(\"finish\", this._onFinishBound);\n    }\n    get bufferSize() {\n        return this._channel && this._channel.bufferedAmount || 0;\n    }\n    // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    get connected() {\n        return this._connected && this._channel.readyState === \"open\";\n    }\n    address() {\n        return {\n            port: this.localPort,\n            family: this.localFamily,\n            address: this.localAddress\n        };\n    }\n    signal(data) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot signal after peer is destroyed\"), \"ERR_DESTROYED\");\n        if (typeof data === \"string\") {\n            try {\n                data = JSON.parse(data);\n            } catch (err) {\n                data = {};\n            }\n        }\n        this._debug(\"signal()\");\n        if (data.renegotiate && this.initiator) {\n            this._debug(\"got request to renegotiate\");\n            this._needsNegotiation();\n        }\n        if (data.transceiverRequest && this.initiator) {\n            this._debug(\"got request for transceiver\");\n            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n        }\n        if (data.candidate) {\n            if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n                this._addIceCandidate(data.candidate);\n            } else {\n                this._pendingCandidates.push(data.candidate);\n            }\n        }\n        if (data.sdp) {\n            this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(()=>{\n                if (this.destroyed) return;\n                this._pendingCandidates.forEach((candidate)=>{\n                    this._addIceCandidate(candidate);\n                });\n                this._pendingCandidates = [];\n                if (this._pc.remoteDescription.type === \"offer\") this._createAnswer();\n            }).catch((err)=>{\n                this.destroy(errCode(err, \"ERR_SET_REMOTE_DESCRIPTION\"));\n            });\n        }\n        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n            this.destroy(errCode(new Error(\"signal() called with invalid signal data\"), \"ERR_SIGNALING\"));\n        }\n    }\n    _addIceCandidate(candidate) {\n        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);\n        this._pc.addIceCandidate(iceCandidateObj).catch((err)=>{\n            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(\".local\")) {\n                warn(\"Ignoring unsupported ICE candidate.\");\n            } else {\n                this.destroy(errCode(err, \"ERR_ADD_ICE_CANDIDATE\"));\n            }\n        });\n    }\n    /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */ send(chunk) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot send after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._channel.send(chunk);\n    }\n    /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */ addTransceiver(kind, init) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot addTransceiver after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addTransceiver()\");\n        if (this.initiator) {\n            try {\n                this._pc.addTransceiver(kind, init);\n                this._needsNegotiation();\n            } catch (err) {\n                this.destroy(errCode(err, \"ERR_ADD_TRANSCEIVER\"));\n            }\n        } else {\n            this.emit(\"signal\", {\n                type: \"transceiverRequest\",\n                transceiverRequest: {\n                    kind,\n                    init\n                }\n            });\n        }\n    }\n    /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */ addStream(stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot addStream after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addStream()\");\n        stream.getTracks().forEach((track)=>{\n            this.addTrack(track, stream);\n        });\n    }\n    /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */ addTrack(track, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot addTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addTrack()\");\n        const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n        ;\n        let sender = submap.get(stream);\n        if (!sender) {\n            sender = this._pc.addTrack(track, stream);\n            submap.set(stream, sender);\n            this._senderMap.set(track, submap);\n            this._needsNegotiation();\n        } else if (sender.removed) {\n            throw errCode(new Error(\"Track has been removed. You should enable/disable tracks that you want to re-add.\"), \"ERR_SENDER_REMOVED\");\n        } else {\n            throw errCode(new Error(\"Track has already been added to that stream.\"), \"ERR_SENDER_ALREADY_ADDED\");\n        }\n    }\n    /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */ replaceTrack(oldTrack, newTrack, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot replaceTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"replaceTrack()\");\n        const submap = this._senderMap.get(oldTrack);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) {\n            throw errCode(new Error(\"Cannot replace track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n        }\n        if (newTrack) this._senderMap.set(newTrack, submap);\n        if (sender.replaceTrack != null) {\n            sender.replaceTrack(newTrack);\n        } else {\n            this.destroy(errCode(new Error(\"replaceTrack is not supported in this browser\"), \"ERR_UNSUPPORTED_REPLACETRACK\"));\n        }\n    }\n    /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */ removeTrack(track, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot removeTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"removeSender()\");\n        const submap = this._senderMap.get(track);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) {\n            throw errCode(new Error(\"Cannot remove track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n        }\n        try {\n            sender.removed = true;\n            this._pc.removeTrack(sender);\n        } catch (err) {\n            if (err.name === \"NS_ERROR_UNEXPECTED\") {\n                this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n                ;\n            } else {\n                this.destroy(errCode(err, \"ERR_REMOVE_TRACK\"));\n            }\n        }\n        this._needsNegotiation();\n    }\n    /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */ removeStream(stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot removeStream after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"removeSenders()\");\n        stream.getTracks().forEach((track)=>{\n            this.removeTrack(track, stream);\n        });\n    }\n    _needsNegotiation() {\n        this._debug(\"_needsNegotiation\");\n        if (this._batchedNegotiation) return; // batch synchronous renegotiations\n        this._batchedNegotiation = true;\n        queueMicrotask(()=>{\n            this._batchedNegotiation = false;\n            if (this.initiator || !this._firstNegotiation) {\n                this._debug(\"starting batched negotiation\");\n                this.negotiate();\n            } else {\n                this._debug(\"non-initiator initial negotiation request discarded\");\n            }\n            this._firstNegotiation = false;\n        });\n    }\n    negotiate() {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot negotiate after peer is destroyed\"), \"ERR_DESTROYED\");\n        if (this.initiator) {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true;\n                this._debug(\"already negotiating, queueing\");\n            } else {\n                this._debug(\"start negotiation\");\n                setTimeout(()=>{\n                    this._createOffer();\n                }, 0);\n            }\n        } else {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true;\n                this._debug(\"already negotiating, queueing\");\n            } else {\n                this._debug(\"requesting negotiation from initiator\");\n                this.emit(\"signal\", {\n                    type: \"renegotiate\",\n                    renegotiate: true\n                });\n            }\n        }\n        this._isNegotiating = true;\n    }\n    // TODO: Delete this method once readable-stream is updated to contain a default\n    // implementation of destroy() that automatically calls _destroy()\n    // See: https://github.com/nodejs/readable-stream/issues/283\n    destroy(err) {\n        this._destroy(err, ()=>{});\n    }\n    _destroy(err, cb) {\n        if (this.destroyed || this.destroying) return;\n        this.destroying = true;\n        this._debug(\"destroying (error: %s)\", err && (err.message || err));\n        queueMicrotask(()=>{\n            this.destroyed = true;\n            this.destroying = false;\n            this._debug(\"destroy (error: %s)\", err && (err.message || err));\n            this.readable = this.writable = false;\n            if (!this._readableState.ended) this.push(null);\n            if (!this._writableState.finished) this.end();\n            this._connected = false;\n            this._pcReady = false;\n            this._channelReady = false;\n            this._remoteTracks = null;\n            this._remoteStreams = null;\n            this._senderMap = null;\n            clearInterval(this._closingInterval);\n            this._closingInterval = null;\n            clearInterval(this._interval);\n            this._interval = null;\n            this._chunk = null;\n            this._cb = null;\n            if (this._onFinishBound) this.removeListener(\"finish\", this._onFinishBound);\n            this._onFinishBound = null;\n            if (this._channel) {\n                try {\n                    this._channel.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._channel.onmessage = null;\n                this._channel.onopen = null;\n                this._channel.onclose = null;\n                this._channel.onerror = null;\n            }\n            if (this._pc) {\n                try {\n                    this._pc.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._pc.oniceconnectionstatechange = null;\n                this._pc.onicegatheringstatechange = null;\n                this._pc.onsignalingstatechange = null;\n                this._pc.onicecandidate = null;\n                this._pc.ontrack = null;\n                this._pc.ondatachannel = null;\n            }\n            this._pc = null;\n            this._channel = null;\n            if (err) this.emit(\"error\", err);\n            this.emit(\"close\");\n            cb();\n        });\n    }\n    _setupData(event) {\n        if (!event.channel) {\n            // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n            // which is invalid behavior. Handle it gracefully.\n            // See: https://github.com/feross/simple-peer/issues/163\n            return this.destroy(errCode(new Error(\"Data channel event is missing `channel` property\"), \"ERR_DATA_CHANNEL\"));\n        }\n        this._channel = event.channel;\n        this._channel.binaryType = \"arraybuffer\";\n        if (typeof this._channel.bufferedAmountLowThreshold === \"number\") {\n            this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;\n        }\n        this.channelName = this._channel.label;\n        this._channel.onmessage = (event)=>{\n            this._onChannelMessage(event);\n        };\n        this._channel.onbufferedamountlow = ()=>{\n            this._onChannelBufferedAmountLow();\n        };\n        this._channel.onopen = ()=>{\n            this._onChannelOpen();\n        };\n        this._channel.onclose = ()=>{\n            this._onChannelClose();\n        };\n        this._channel.onerror = (event)=>{\n            const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`);\n            this.destroy(errCode(err, \"ERR_DATA_CHANNEL\"));\n        };\n        // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n        let isClosing = false;\n        this._closingInterval = setInterval(()=>{\n            if (this._channel && this._channel.readyState === \"closing\") {\n                if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n                ;\n                isClosing = true;\n            } else {\n                isClosing = false;\n            }\n        }, CHANNEL_CLOSING_TIMEOUT);\n    }\n    _read() {}\n    _write(chunk, encoding, cb) {\n        if (this.destroyed) return cb(errCode(new Error(\"cannot write after peer is destroyed\"), \"ERR_DATA_CHANNEL\"));\n        if (this._connected) {\n            try {\n                this.send(chunk);\n            } catch (err) {\n                return this.destroy(errCode(err, \"ERR_DATA_CHANNEL\"));\n            }\n            if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n                this._debug(\"start backpressure: bufferedAmount %d\", this._channel.bufferedAmount);\n                this._cb = cb;\n            } else {\n                cb(null);\n            }\n        } else {\n            this._debug(\"write before connect\");\n            this._chunk = chunk;\n            this._cb = cb;\n        }\n    }\n    // When stream finishes writing, close socket. Half open connections are not\n    // supported.\n    _onFinish() {\n        if (this.destroyed) return;\n        // Wait a bit before destroying so the socket flushes.\n        // TODO: is there a more reliable way to accomplish this?\n        const destroySoon = ()=>{\n            setTimeout(()=>this.destroy(), 1000);\n        };\n        if (this._connected) {\n            destroySoon();\n        } else {\n            this.once(\"connect\", destroySoon);\n        }\n    }\n    _startIceCompleteTimeout() {\n        if (this.destroyed) return;\n        if (this._iceCompleteTimer) return;\n        this._debug(\"started iceComplete timeout\");\n        this._iceCompleteTimer = setTimeout(()=>{\n            if (!this._iceComplete) {\n                this._iceComplete = true;\n                this._debug(\"iceComplete timeout completed\");\n                this.emit(\"iceTimeout\");\n                this.emit(\"_iceComplete\");\n            }\n        }, this.iceCompleteTimeout);\n    }\n    _createOffer() {\n        if (this.destroyed) return;\n        this._pc.createOffer(this.offerOptions).then((offer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);\n            offer.sdp = this.sdpTransform(offer.sdp);\n            const sendOffer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || offer;\n                this._debug(\"signal\");\n                this.emit(\"signal\", {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n            };\n            const onSuccess = ()=>{\n                this._debug(\"createOffer success\");\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendOffer();\n                else this.once(\"_iceComplete\", sendOffer) // wait for candidates\n                ;\n            };\n            const onError = (err)=>{\n                this.destroy(errCode(err, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            };\n            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.destroy(errCode(err, \"ERR_CREATE_OFFER\"));\n        });\n    }\n    _requestMissingTransceivers() {\n        if (this._pc.getTransceivers) {\n            this._pc.getTransceivers().forEach((transceiver)=>{\n                if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n                    transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n                    ;\n                    this.addTransceiver(transceiver.sender.track.kind);\n                }\n            });\n        }\n    }\n    _createAnswer() {\n        if (this.destroyed) return;\n        this._pc.createAnswer(this.answerOptions).then((answer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);\n            answer.sdp = this.sdpTransform(answer.sdp);\n            const sendAnswer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || answer;\n                this._debug(\"signal\");\n                this.emit(\"signal\", {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n                if (!this.initiator) this._requestMissingTransceivers();\n            };\n            const onSuccess = ()=>{\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendAnswer();\n                else this.once(\"_iceComplete\", sendAnswer);\n            };\n            const onError = (err)=>{\n                this.destroy(errCode(err, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            };\n            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.destroy(errCode(err, \"ERR_CREATE_ANSWER\"));\n        });\n    }\n    _onConnectionStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.connectionState === \"failed\") {\n            this.destroy(errCode(new Error(\"Connection failed.\"), \"ERR_CONNECTION_FAILURE\"));\n        }\n    }\n    _onIceStateChange() {\n        if (this.destroyed) return;\n        const iceConnectionState = this._pc.iceConnectionState;\n        const iceGatheringState = this._pc.iceGatheringState;\n        this._debug(\"iceStateChange (connection: %s) (gathering: %s)\", iceConnectionState, iceGatheringState);\n        this.emit(\"iceStateChange\", iceConnectionState, iceGatheringState);\n        if (iceConnectionState === \"connected\" || iceConnectionState === \"completed\") {\n            this._pcReady = true;\n            this._maybeReady();\n        }\n        if (iceConnectionState === \"failed\") {\n            this.destroy(errCode(new Error(\"Ice connection failed.\"), \"ERR_ICE_CONNECTION_FAILURE\"));\n        }\n        if (iceConnectionState === \"closed\") {\n            this.destroy(errCode(new Error(\"Ice connection closed.\"), \"ERR_ICE_CONNECTION_CLOSED\"));\n        }\n    }\n    getStats(cb) {\n        // statreports can come with a value array instead of properties\n        const flattenValues = (report)=>{\n            if (Object.prototype.toString.call(report.values) === \"[object Array]\") {\n                report.values.forEach((value)=>{\n                    Object.assign(report, value);\n                });\n            }\n            return report;\n        };\n        // Promise-based getStats() (standard)\n        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n            this._pc.getStats().then((res)=>{\n                const reports = [];\n                res.forEach((report)=>{\n                    reports.push(flattenValues(report));\n                });\n                cb(null, reports);\n            }, (err)=>cb(err));\n        // Single-parameter callback-based getStats() (non-standard)\n        } else if (this._pc.getStats.length > 0) {\n            this._pc.getStats((res)=>{\n                // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n                if (this.destroyed) return;\n                const reports = [];\n                res.result().forEach((result)=>{\n                    const report = {};\n                    result.names().forEach((name)=>{\n                        report[name] = result.stat(name);\n                    });\n                    report.id = result.id;\n                    report.type = result.type;\n                    report.timestamp = result.timestamp;\n                    reports.push(flattenValues(report));\n                });\n                cb(null, reports);\n            }, (err)=>cb(err));\n        // Unknown browser, skip getStats() since it's anyone's guess which style of\n        // getStats() they implement.\n        } else {\n            cb(null, []);\n        }\n    }\n    _maybeReady() {\n        this._debug(\"maybeReady pc %s channel %s\", this._pcReady, this._channelReady);\n        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n        this._connecting = true;\n        // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n        const findCandidatePair = ()=>{\n            if (this.destroyed) return;\n            this.getStats((err, items)=>{\n                if (this.destroyed) return;\n                // Treat getStats error as non-fatal. It's not essential.\n                if (err) items = [];\n                const remoteCandidates = {};\n                const localCandidates = {};\n                const candidatePairs = {};\n                let foundSelectedCandidatePair = false;\n                items.forEach((item)=>{\n                    // TODO: Once all browsers support the hyphenated stats report types, remove\n                    // the non-hypenated ones\n                    if (item.type === \"remotecandidate\" || item.type === \"remote-candidate\") {\n                        remoteCandidates[item.id] = item;\n                    }\n                    if (item.type === \"localcandidate\" || item.type === \"local-candidate\") {\n                        localCandidates[item.id] = item;\n                    }\n                    if (item.type === \"candidatepair\" || item.type === \"candidate-pair\") {\n                        candidatePairs[item.id] = item;\n                    }\n                });\n                const setSelectedCandidatePair = (selectedCandidatePair)=>{\n                    foundSelectedCandidatePair = true;\n                    let local = localCandidates[selectedCandidatePair.localCandidateId];\n                    if (local && (local.ip || local.address)) {\n                        // Spec\n                        this.localAddress = local.ip || local.address;\n                        this.localPort = Number(local.port);\n                    } else if (local && local.ipAddress) {\n                        // Firefox\n                        this.localAddress = local.ipAddress;\n                        this.localPort = Number(local.portNumber);\n                    } else if (typeof selectedCandidatePair.googLocalAddress === \"string\") {\n                        // TODO: remove this once Chrome 58 is released\n                        local = selectedCandidatePair.googLocalAddress.split(\":\");\n                        this.localAddress = local[0];\n                        this.localPort = Number(local[1]);\n                    }\n                    if (this.localAddress) {\n                        this.localFamily = this.localAddress.includes(\":\") ? \"IPv6\" : \"IPv4\";\n                    }\n                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n                    if (remote && (remote.ip || remote.address)) {\n                        // Spec\n                        this.remoteAddress = remote.ip || remote.address;\n                        this.remotePort = Number(remote.port);\n                    } else if (remote && remote.ipAddress) {\n                        // Firefox\n                        this.remoteAddress = remote.ipAddress;\n                        this.remotePort = Number(remote.portNumber);\n                    } else if (typeof selectedCandidatePair.googRemoteAddress === \"string\") {\n                        // TODO: remove this once Chrome 58 is released\n                        remote = selectedCandidatePair.googRemoteAddress.split(\":\");\n                        this.remoteAddress = remote[0];\n                        this.remotePort = Number(remote[1]);\n                    }\n                    if (this.remoteAddress) {\n                        this.remoteFamily = this.remoteAddress.includes(\":\") ? \"IPv6\" : \"IPv4\";\n                    }\n                    this._debug(\"connect local: %s:%s remote: %s:%s\", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n                };\n                items.forEach((item)=>{\n                    // Spec-compliant\n                    if (item.type === \"transport\" && item.selectedCandidatePairId) {\n                        setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n                    }\n                    // Old implementations\n                    if (item.type === \"googCandidatePair\" && item.googActiveConnection === \"true\" || (item.type === \"candidatepair\" || item.type === \"candidate-pair\") && item.selected) {\n                        setSelectedCandidatePair(item);\n                    }\n                });\n                // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n                // But wait until at least 1 candidate pair is available\n                if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n                    setTimeout(findCandidatePair, 100);\n                    return;\n                } else {\n                    this._connecting = false;\n                    this._connected = true;\n                }\n                if (this._chunk) {\n                    try {\n                        this.send(this._chunk);\n                    } catch (err) {\n                        return this.destroy(errCode(err, \"ERR_DATA_CHANNEL\"));\n                    }\n                    this._chunk = null;\n                    this._debug('sent chunk from \"write before connect\"');\n                    const cb = this._cb;\n                    this._cb = null;\n                    cb(null);\n                }\n                // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n                // fallback to using setInterval to implement backpressure.\n                if (typeof this._channel.bufferedAmountLowThreshold !== \"number\") {\n                    this._interval = setInterval(()=>this._onInterval(), 150);\n                    if (this._interval.unref) this._interval.unref();\n                }\n                this._debug(\"connect\");\n                this.emit(\"connect\");\n            });\n        };\n        findCandidatePair();\n    }\n    _onInterval() {\n        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n            return;\n        }\n        this._onChannelBufferedAmountLow();\n    }\n    _onSignalingStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.signalingState === \"stable\") {\n            this._isNegotiating = false;\n            // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n            this._debug(\"flushing sender queue\", this._sendersAwaitingStable);\n            this._sendersAwaitingStable.forEach((sender)=>{\n                this._pc.removeTrack(sender);\n                this._queuedNegotiation = true;\n            });\n            this._sendersAwaitingStable = [];\n            if (this._queuedNegotiation) {\n                this._debug(\"flushing negotiation queue\");\n                this._queuedNegotiation = false;\n                this._needsNegotiation() // negotiate again\n                ;\n            } else {\n                this._debug(\"negotiated\");\n                this.emit(\"negotiated\");\n            }\n        }\n        this._debug(\"signalingStateChange %s\", this._pc.signalingState);\n        this.emit(\"signalingStateChange\", this._pc.signalingState);\n    }\n    _onIceCandidate(event) {\n        if (this.destroyed) return;\n        if (event.candidate && this.trickle) {\n            this.emit(\"signal\", {\n                type: \"candidate\",\n                candidate: {\n                    candidate: event.candidate.candidate,\n                    sdpMLineIndex: event.candidate.sdpMLineIndex,\n                    sdpMid: event.candidate.sdpMid\n                }\n            });\n        } else if (!event.candidate && !this._iceComplete) {\n            this._iceComplete = true;\n            this.emit(\"_iceComplete\");\n        }\n        // as soon as we've received one valid candidate start timeout\n        if (event.candidate) {\n            this._startIceCompleteTimeout();\n        }\n    }\n    _onChannelMessage(event) {\n        if (this.destroyed) return;\n        let data = event.data;\n        if (data instanceof ArrayBuffer) data = Buffer.from(data);\n        this.push(data);\n    }\n    _onChannelBufferedAmountLow() {\n        if (this.destroyed || !this._cb) return;\n        this._debug(\"ending backpressure: bufferedAmount %d\", this._channel.bufferedAmount);\n        const cb = this._cb;\n        this._cb = null;\n        cb(null);\n    }\n    _onChannelOpen() {\n        if (this._connected || this.destroyed) return;\n        this._debug(\"on channel open\");\n        this._channelReady = true;\n        this._maybeReady();\n    }\n    _onChannelClose() {\n        if (this.destroyed) return;\n        this._debug(\"on channel close\");\n        this.destroy();\n    }\n    _onTrack(event) {\n        if (this.destroyed) return;\n        event.streams.forEach((eventStream)=>{\n            this._debug(\"on track\");\n            this.emit(\"track\", event.track, eventStream);\n            this._remoteTracks.push({\n                track: event.track,\n                stream: eventStream\n            });\n            if (this._remoteStreams.some((remoteStream)=>{\n                return remoteStream.id === eventStream.id;\n            })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream\n            this._remoteStreams.push(eventStream);\n            queueMicrotask(()=>{\n                this._debug(\"on stream\");\n                this.emit(\"stream\", eventStream) // ensure all tracks have been added\n                ;\n            });\n        });\n    }\n    _debug() {\n        const args = [].slice.call(arguments);\n        args[0] = \"[\" + this._id + \"] \" + args[0];\n        debug.apply(null, args);\n    }\n}\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */ Peer.config = {\n    iceServers: [\n        {\n            urls: [\n                \"stun:stun.l.google.com:19302\",\n                \"stun:global.stun.twilio.com:3478\"\n            ]\n        }\n    ],\n    sdpSemantics: \"unified-plan\"\n};\nPeer.channelConfig = {};\nmodule.exports = Peer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsa0ZBQWtGLEdBQ2xGLE1BQU1BLFFBQVFDLG1CQUFPQSxDQUFDLHdEQUFTO0FBQy9CLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksaUJBQWlCSixtQkFBT0EsQ0FBQyx3RUFBbUIsNkNBQTZDOztBQUMvRixNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVNLE1BQU0sRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUUzQixNQUFNTyxzQkFBc0IsS0FBSztBQUNqQyxNQUFNQyxzQkFBc0IsSUFBSTtBQUNoQyxNQUFNQywwQkFBMEIsSUFBSTtBQUVwQywyREFBMkQ7QUFDM0QsU0FBU0MsY0FBZUMsR0FBRztJQUN6QixPQUFPQSxJQUFJQyxPQUFPLENBQUMsOEJBQThCO0FBQ25EO0FBRUEsU0FBU0MsS0FBTUMsT0FBTztJQUNwQkMsUUFBUUYsSUFBSSxDQUFDQztBQUNmO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FLGFBQWFiLE9BQU9jLE1BQU07SUFDOUJDLFlBQWFDLElBQUksQ0FBRTtRQUNqQkEsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1lBQ25CQyxlQUFlO1FBQ2pCLEdBQUdIO1FBRUgsS0FBSyxDQUFDQTtRQUVOLElBQUksQ0FBQ0ksR0FBRyxHQUFHckIsWUFBWSxHQUFHc0IsUUFBUSxDQUFDLE9BQU9DLEtBQUssQ0FBQyxHQUFHO1FBQ25ELElBQUksQ0FBQ0MsTUFBTSxDQUFDLGVBQWVQO1FBRTNCLElBQUksQ0FBQ1EsV0FBVyxHQUFHUixLQUFLUyxTQUFTLEdBQzdCVCxLQUFLUSxXQUFXLElBQUl6QixZQUFZLElBQUlzQixRQUFRLENBQUMsU0FDN0M7UUFFSixJQUFJLENBQUNJLFNBQVMsR0FBR1QsS0FBS1Ms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WUFFQSxJQUFJLElBQUksQ0FBQ3pMLGNBQWMsQ0FBQzBMLElBQUksQ0FBQ0MsQ0FBQUE7Z0JBQzNCLE9BQU9BLGFBQWFyQyxFQUFFLEtBQUttQyxZQUFZbkMsRUFBRTtZQUMzQyxJQUFJLFFBQU8sb0ZBQW9GO1lBRS9GLElBQUksQ0FBQ3RKLGNBQWMsQ0FBQ3NELElBQUksQ0FBQ21JO1lBQ3pCelAsZUFBZTtnQkFDYixJQUFJLENBQUNzQixNQUFNLENBQUM7Z0JBQ1osSUFBSSxDQUFDMkcsSUFBSSxDQUFDLFVBQVV3SCxhQUFhLG9DQUFvQzs7WUFDdkU7UUFDRjtJQUNGO0lBRUFuTyxTQUFVO1FBQ1IsTUFBTXNPLE9BQU8sRUFBRSxDQUFDdk8sS0FBSyxDQUFDd0wsSUFBSSxDQUFDZ0Q7UUFDM0JELElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUN6TyxHQUFHLEdBQUcsT0FBT3lPLElBQUksQ0FBQyxFQUFFO1FBQ3pDalEsTUFBTW1RLEtBQUssQ0FBQyxNQUFNRjtJQUNwQjtBQUNGO0FBRUFoUCxLQUFLbVAsY0FBYyxHQUFHLENBQUMsQ0FBQ2xRO0FBRXhCOzs7O0NBSUMsR0FDRGUsS0FBS2dCLE1BQU0sR0FBRztJQUNab08sWUFBWTtRQUNWO1lBQ0VDLE1BQU07Z0JBQ0o7Z0JBQ0E7YUFDRDtRQUNIO0tBQ0Q7SUFDREMsY0FBYztBQUNoQjtBQUVBdFAsS0FBS2EsYUFBYSxHQUFHLENBQUM7QUFFdEIwTyxPQUFPQyxPQUFPLEdBQUd4UCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbWUtdmlldy8uL25vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9pbmRleC5qcz9hZTliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzaW1wbGUtcGVlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtcGVlcicpXG5jb25zdCBnZXRCcm93c2VyUlRDID0gcmVxdWlyZSgnZ2V0LWJyb3dzZXItcnRjJylcbmNvbnN0IHJhbmRvbWJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbmNvbnN0IHF1ZXVlTWljcm90YXNrID0gcmVxdWlyZSgncXVldWUtbWljcm90YXNrJykgLy8gVE9ETzogcmVtb3ZlIHdoZW4gTm9kZSAxMCBpcyBub3Qgc3VwcG9ydGVkXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbmNvbnN0IE1BWF9CVUZGRVJFRF9BTU9VTlQgPSA2NCAqIDEwMjRcbmNvbnN0IElDRUNPTVBMRVRFX1RJTUVPVVQgPSA1ICogMTAwMFxuY29uc3QgQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQgPSA1ICogMTAwMFxuXG4vLyBIQUNLOiBGaWx0ZXIgdHJpY2tsZSBsaW5lcyB3aGVuIHRyaWNrbGUgaXMgZGlzYWJsZWQgIzM1NFxuZnVuY3Rpb24gZmlsdGVyVHJpY2tsZSAoc2RwKSB7XG4gIHJldHVybiBzZHAucmVwbGFjZSgvYT1pY2Utb3B0aW9uczp0cmlja2xlXFxzXFxuL2csICcnKVxufVxuXG5mdW5jdGlvbiB3YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKVxufVxuXG4vKipcbiAqIFdlYlJUQyBwZWVyIGNvbm5lY3Rpb24uIFNhbWUgQVBJIGFzIG5vZGUgY29yZSBgbmV0LlNvY2tldGAsIHBsdXMgYSBmZXcgZXh0cmEgbWV0aG9kcy5cbiAqIER1cGxleCBzdHJlYW0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5jbGFzcyBQZWVyIGV4dGVuZHMgc3RyZWFtLkR1cGxleCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWxsb3dIYWxmT3BlbjogZmFsc2VcbiAgICB9LCBvcHRzKVxuXG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2lkID0gcmFuZG9tYnl0ZXMoNCkudG9TdHJpbmcoJ2hleCcpLnNsaWNlKDAsIDcpXG4gICAgdGhpcy5fZGVidWcoJ25ldyBwZWVyICVvJywgb3B0cylcblxuICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBvcHRzLmluaXRpYXRvclxuICAgICAgPyBvcHRzLmNoYW5uZWxOYW1lIHx8IHJhbmRvbWJ5dGVzKDIwKS50b1N0cmluZygnaGV4JylcbiAgICAgIDogbnVsbFxuXG4gICAgdGhpcy5pbml0aWF0b3IgPSBvcHRzLmluaXRpYXRvciB8fCBmYWxzZVxuICAgIHRoaXMuY2hhbm5lbENvbmZpZyA9IG9wdHMuY2hhbm5lbENvbmZpZyB8fCBQZWVyLmNoYW5uZWxDb25maWdcbiAgICB0aGlzLmNoYW5uZWxOZWdvdGlhdGVkID0gdGhpcy5jaGFubmVsQ29uZmlnLm5lZ290aWF0ZWRcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIFBlZXIuY29uZmlnLCBvcHRzLmNvbmZpZylcbiAgICB0aGlzLm9mZmVyT3B0aW9ucyA9IG9wdHMub2ZmZXJPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5hbnN3ZXJPcHRpb25zID0gb3B0cy5hbnN3ZXJPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5zZHBUcmFuc2Zvcm0gPSBvcHRzLnNkcFRyYW5zZm9ybSB8fCAoc2RwID0+IHNkcClcbiAgICB0aGlzLnN0cmVhbXMgPSBvcHRzLnN0cmVhbXMgfHwgKG9wdHMuc3RyZWFtID8gW29wdHMuc3RyZWFtXSA6IFtdKSAvLyBzdXBwb3J0IG9sZCBcInN0cmVhbVwiIG9wdGlvblxuICAgIHRoaXMudHJpY2tsZSA9IG9wdHMudHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy50cmlja2xlIDogdHJ1ZVxuICAgIHRoaXMuYWxsb3dIYWxmVHJpY2tsZSA9IG9wdHMuYWxsb3dIYWxmVHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5hbGxvd0hhbGZUcmlja2xlIDogZmFsc2VcbiAgICB0aGlzLmljZUNvbXBsZXRlVGltZW91dCA9IG9wdHMuaWNlQ29tcGxldGVUaW1lb3V0IHx8IElDRUNPTVBMRVRFX1RJTUVPVVRcblxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICB0aGlzLmRlc3Ryb3lpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlbW90ZUZhbWlseSA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3RlUG9ydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxBZGRyZXNzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbEZhbWlseSA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxQb3J0ID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl93cnRjID0gKG9wdHMud3J0YyAmJiB0eXBlb2Ygb3B0cy53cnRjID09PSAnb2JqZWN0JylcbiAgICAgID8gb3B0cy53cnRjXG4gICAgICA6IGdldEJyb3dzZXJSVEMoKVxuXG4gICAgaWYgKCF0aGlzLl93cnRjKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50JyksICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBOb3QgYSBzdXBwb3J0ZWQgYnJvd3NlcicpLCAnRVJSX1dFQlJUQ19TVVBQT1JUJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wY1JlYWR5ID0gZmFsc2VcbiAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gZmFsc2UgLy8gaWNlIGNhbmRpZGF0ZSB0cmlja2xlIGRvbmUgKGdvdCBudWxsIGNhbmRpZGF0ZSlcbiAgICB0aGlzLl9pY2VDb21wbGV0ZVRpbWVyID0gbnVsbCAvLyBzZW5kIGFuIG9mZmVyL2Fuc3dlciBhbnl3YXkgYWZ0ZXIgc29tZSB0aW1lb3V0XG4gICAgdGhpcy5fY2hhbm5lbCA9IG51bGxcbiAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG5cbiAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gZmFsc2UgLy8gaXMgdGhpcyBwZWVyIHdhaXRpbmcgZm9yIG5lZ290aWF0aW9uIHRvIGNvbXBsZXRlP1xuICAgIHRoaXMuX2ZpcnN0TmVnb3RpYXRpb24gPSB0cnVlXG4gICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gZmFsc2UgLy8gYmF0Y2ggc3luY2hyb25vdXMgbmVnb3RpYXRpb25zXG4gICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBpcyB0aGVyZSBhIHF1ZXVlZCBuZWdvdGlhdGlvbiByZXF1ZXN0P1xuICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSA9IFtdXG4gICAgdGhpcy5fc2VuZGVyTWFwID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gbnVsbFxuXG4gICAgdGhpcy5fcmVtb3RlVHJhY2tzID0gW11cbiAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW11cblxuICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgIHRoaXMuX2NiID0gbnVsbFxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3BjID0gbmV3ICh0aGlzLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSh0aGlzLmNvbmZpZylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9QQ19DT05TVFJVQ1RPUicpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gV2UgcHJlZmVyIGZlYXR1cmUgZGV0ZWN0aW9uIHdoZW5ldmVyIHBvc3NpYmxlLCBidXQgc29tZXRpbWVzIHRoYXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSBmb3IgY2VydGFpbiBpbXBsZW1lbnRhdGlvbnMuXG4gICAgdGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0YyA9IHR5cGVvZiB0aGlzLl9wYy5fcGVlckNvbm5lY3Rpb25JZCA9PT0gJ251bWJlcidcblxuICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkljZVN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vbkljZUNhbmRpZGF0ZShldmVudClcbiAgICB9XG5cbiAgICAvLyBIQUNLOiBGaXggZm9yIG9kZCBGaXJlZm94IGJlaGF2aW9yLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvcHVsbC83ODNcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BjLnBlZXJJZGVudGl0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX3BjLnBlZXJJZGVudGl0eS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfUENfUEVFUl9JREVOVElUWScpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBPdGhlciBzcGVjIGV2ZW50cywgdW51c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb246XG4gICAgLy8gLSBvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZVxuICAgIC8vIC0gb25pY2VjYW5kaWRhdGVlcnJvclxuICAgIC8vIC0gb25maW5nZXJwcmludGZhaWx1cmVcbiAgICAvLyAtIG9ubmVnb3RpYXRpb25uZWVkZWRcblxuICAgIGlmICh0aGlzLmluaXRpYXRvciB8fCB0aGlzLmNoYW5uZWxOZWdvdGlhdGVkKSB7XG4gICAgICB0aGlzLl9zZXR1cERhdGEoe1xuICAgICAgICBjaGFubmVsOiB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lLCB0aGlzLmNoYW5uZWxDb25maWcpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXR1cERhdGEoZXZlbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RyZWFtcykge1xuICAgICAgdGhpcy5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdHJlYW0oc3RyZWFtKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5fcGMub250cmFjayA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uVHJhY2soZXZlbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ2luaXRpYWwgbmVnb3RpYXRpb24nKVxuICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuXG4gICAgdGhpcy5fb25GaW5pc2hCb3VuZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uRmluaXNoKClcbiAgICB9XG4gICAgdGhpcy5vbmNlKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaEJvdW5kKVxuICB9XG5cbiAgZ2V0IGJ1ZmZlclNpemUgKCkge1xuICAgIHJldHVybiAodGhpcy5fY2hhbm5lbCAmJiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSB8fCAwXG4gIH1cblxuICAvLyBIQUNLOiBpdCdzIHBvc3NpYmxlIGNoYW5uZWwucmVhZHlTdGF0ZSBpcyBcImNsb3NpbmdcIiBiZWZvcmUgcGVlci5kZXN0cm95KCkgZmlyZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5fY29ubmVjdGVkICYmIHRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKVxuICB9XG5cbiAgYWRkcmVzcyAoKSB7XG4gICAgcmV0dXJuIHsgcG9ydDogdGhpcy5sb2NhbFBvcnQsIGZhbWlseTogdGhpcy5sb2NhbEZhbWlseSwgYWRkcmVzczogdGhpcy5sb2NhbEFkZHJlc3MgfVxuICB9XG5cbiAgc2lnbmFsIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkYXRhID0ge31cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ3NpZ25hbCgpJylcblxuICAgIGlmIChkYXRhLnJlbmVnb3RpYXRlICYmIHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHJlcXVlc3QgdG8gcmVuZWdvdGlhdGUnKVxuICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gICAgfVxuICAgIGlmIChkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdCAmJiB0aGlzLmluaXRpYXRvcikge1xuICAgICAgdGhpcy5fZGVidWcoJ2dvdCByZXF1ZXN0IGZvciB0cmFuc2NlaXZlcicpXG4gICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmtpbmQsIGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmluaXQpXG4gICAgfVxuICAgIGlmIChkYXRhLmNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uICYmIHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkSWNlQ2FuZGlkYXRlKGRhdGEuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChkYXRhLmNhbmRpZGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuc2RwKSB7XG4gICAgICB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgKHRoaXMuX3dydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShkYXRhKSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHRoaXMuX2NyZWF0ZUFuc3dlcigpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfUkVNT1RFX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGlmICghZGF0YS5zZHAgJiYgIWRhdGEuY2FuZGlkYXRlICYmICFkYXRhLnJlbmVnb3RpYXRlICYmICFkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdCkge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdzaWduYWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIHNpZ25hbCBkYXRhJyksICdFUlJfU0lHTkFMSU5HJykpXG4gICAgfVxuICB9XG5cbiAgX2FkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgY29uc3QgaWNlQ2FuZGlkYXRlT2JqID0gbmV3IHRoaXMuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICB0aGlzLl9wYy5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlT2JqKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICghaWNlQ2FuZGlkYXRlT2JqLmFkZHJlc3MgfHwgaWNlQ2FuZGlkYXRlT2JqLmFkZHJlc3MuZW5kc1dpdGgoJy5sb2NhbCcpKSB7XG4gICAgICAgICAgd2FybignSWdub3JpbmcgdW5zdXBwb3J0ZWQgSUNFIGNhbmRpZGF0ZS4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9BRERfSUNFX0NBTkRJREFURScpKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYn0gY2h1bmtcbiAgICovXG4gIHNlbmQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHNlbmQgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2NoYW5uZWwuc2VuZChjaHVuaylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBUcmFuc2NlaXZlciB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtpbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGluaXRcbiAgICovXG4gIGFkZFRyYW5zY2VpdmVyIChraW5kLCBpbml0KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IGFkZFRyYW5zY2VpdmVyIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygnYWRkVHJhbnNjZWl2ZXIoKScpXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKGtpbmQsIGluaXQpXG4gICAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9BRERfVFJBTlNDRUlWRVInKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7IC8vIHJlcXVlc3QgaW5pdGlhdG9yIHRvIHJlbmVnb3RpYXRlXG4gICAgICAgIHR5cGU6ICd0cmFuc2NlaXZlclJlcXVlc3QnLFxuICAgICAgICB0cmFuc2NlaXZlclJlcXVlc3Q6IHsga2luZCwgaW5pdCB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBNZWRpYVN0cmVhbSB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICBhZGRTdHJlYW0gKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBhZGRTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRTdHJlYW0oKScpXG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0aGlzLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBNZWRpYVN0cmVhbVRyYWNrIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgYWRkVHJhY2sgKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgYWRkVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRUcmFjaygpJylcblxuICAgIGNvbnN0IHN1Ym1hcCA9IHRoaXMuX3NlbmRlck1hcC5nZXQodHJhY2spIHx8IG5ldyBNYXAoKSAvLyBuZXN0ZWQgTWFwcyBtYXAgW3RyYWNrLCBzdHJlYW1dIHRvIHNlbmRlclxuICAgIGxldCBzZW5kZXIgPSBzdWJtYXAuZ2V0KHN0cmVhbSlcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgc2VuZGVyID0gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICAgIHN1Ym1hcC5zZXQoc3RyZWFtLCBzZW5kZXIpXG4gICAgICB0aGlzLl9zZW5kZXJNYXAuc2V0KHRyYWNrLCBzdWJtYXApXG4gICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICB9IGVsc2UgaWYgKHNlbmRlci5yZW1vdmVkKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVHJhY2sgaGFzIGJlZW4gcmVtb3ZlZC4gWW91IHNob3VsZCBlbmFibGUvZGlzYWJsZSB0cmFja3MgdGhhdCB5b3Ugd2FudCB0byByZS1hZGQuJyksICdFUlJfU0VOREVSX1JFTU9WRUQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVHJhY2sgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGF0IHN0cmVhbS4nKSwgJ0VSUl9TRU5ERVJfQUxSRUFEWV9BRERFRCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBNZWRpYVN0cmVhbVRyYWNrIGJ5IGFub3RoZXIgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gb2xkVHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBuZXdUcmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlcGxhY2VUcmFjayAob2xkVHJhY2ssIG5ld1RyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgcmVwbGFjZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVwbGFjZVRyYWNrKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldChvbGRUcmFjaylcbiAgICBjb25zdCBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgcmVwbGFjZSB0cmFjayB0aGF0IHdhcyBuZXZlciBhZGRlZC4nKSwgJ0VSUl9UUkFDS19OT1RfQURERUQnKVxuICAgIH1cbiAgICBpZiAobmV3VHJhY2spIHRoaXMuX3NlbmRlck1hcC5zZXQobmV3VHJhY2ssIHN1Ym1hcClcblxuICAgIGlmIChzZW5kZXIucmVwbGFjZVRyYWNrICE9IG51bGwpIHtcbiAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobmV3VHJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcigncmVwbGFjZVRyYWNrIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyksICdFUlJfVU5TVVBQT1JURURfUkVQTEFDRVRSQUNLJykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIE1lZGlhU3RyZWFtVHJhY2sgZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlbW92ZVRyYWNrICh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHJlbW92ZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVtb3ZlU2VuZGVyKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldCh0cmFjaylcbiAgICBjb25zdCBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLicpLCAnRVJSX1RSQUNLX05PVF9BRERFRCcpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZW5kZXIucmVtb3ZlZCA9IHRydWVcbiAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHNlbmRlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gJ05TX0VSUk9SX1VORVhQRUNURUQnKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZS5wdXNoKHNlbmRlcikgLy8gSEFDSzogRmlyZWZveCBtdXN0IHdhaXQgdW50aWwgKHNpZ25hbGluZ1N0YXRlID09PSBzdGFibGUpIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMzM4NzRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9SRU1PVkVfVFJBQ0snKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgTWVkaWFTdHJlYW0gZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICByZW1vdmVTdHJlYW0gKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCByZW1vdmVTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZW1vdmVTZW5kZXJzKCknKVxuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVUcmFjayh0cmFjaywgc3RyZWFtKVxuICAgIH0pXG4gIH1cblxuICBfbmVlZHNOZWdvdGlhdGlvbiAoKSB7XG4gICAgdGhpcy5fZGVidWcoJ19uZWVkc05lZ290aWF0aW9uJylcbiAgICBpZiAodGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uKSByZXR1cm4gLy8gYmF0Y2ggc3luY2hyb25vdXMgcmVuZWdvdGlhdGlvbnNcbiAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLmluaXRpYXRvciB8fCAhdGhpcy5fZmlyc3ROZWdvdGlhdGlvbikge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc3RhcnRpbmcgYmF0Y2hlZCBuZWdvdGlhdGlvbicpXG4gICAgICAgIHRoaXMubmVnb3RpYXRlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdub24taW5pdGlhdG9yIGluaXRpYWwgbmVnb3RpYXRpb24gcmVxdWVzdCBkaXNjYXJkZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5fZmlyc3ROZWdvdGlhdGlvbiA9IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIG5lZ290aWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IG5lZ290aWF0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIGlmICh0aGlzLl9pc05lZ290aWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3N0YXJ0IG5lZ290aWF0aW9uJylcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIEhBQ0s6IENocm9tZSBjcmFzaGVzIGlmIHdlIGltbWVkaWF0ZWx5IGNhbGwgY3JlYXRlT2ZmZXJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVPZmZlcigpXG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pc05lZ290aWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3JlcXVlc3RpbmcgbmVnb3RpYXRpb24gZnJvbSBpbml0aWF0b3InKVxuICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHsgLy8gcmVxdWVzdCBpbml0aWF0b3IgdG8gcmVuZWdvdGlhdGVcbiAgICAgICAgICB0eXBlOiAncmVuZWdvdGlhdGUnLFxuICAgICAgICAgIHJlbmVnb3RpYXRlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSB0cnVlXG4gIH1cblxuICAvLyBUT0RPOiBEZWxldGUgdGhpcyBtZXRob2Qgb25jZSByZWFkYWJsZS1zdHJlYW0gaXMgdXBkYXRlZCB0byBjb250YWluIGEgZGVmYXVsdFxuICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBkZXN0cm95KCkgdGhhdCBhdXRvbWF0aWNhbGx5IGNhbGxzIF9kZXN0cm95KClcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3JlYWRhYmxlLXN0cmVhbS9pc3N1ZXMvMjgzXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIHRoaXMuX2Rlc3Ryb3koZXJyLCAoKSA9PiB7fSlcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8IHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgdGhpcy5kZXN0cm95aW5nID0gdHJ1ZVxuXG4gICAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3lpbmcgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7IC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggdGhlIGNhbGwgdG8gX2Rlc3Ryb3koKSB0byBmaXJlIChzZWUgIzY5MilcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgdGhpcy5kZXN0cm95aW5nID0gZmFsc2VcblxuICAgICAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgICAgIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB0aGlzLnB1c2gobnVsbClcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgdGhpcy5lbmQoKVxuXG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5fcGNSZWFkeSA9IGZhbHNlXG4gICAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICAgICAgdGhpcy5fcmVtb3RlVHJhY2tzID0gbnVsbFxuICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IG51bGxcbiAgICAgIHRoaXMuX3NlbmRlck1hcCA9IG51bGxcblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jbG9zaW5nSW50ZXJ2YWwpXG4gICAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBudWxsXG5cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgICAgdGhpcy5fY2IgPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLl9vbkZpbmlzaEJvdW5kKSB0aGlzLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaEJvdW5kKVxuICAgICAgdGhpcy5fb25GaW5pc2hCb3VuZCA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9jaGFubmVsLmNsb3NlKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgICAgIC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggZGVzdHJ1Y3Rpb24gdG8gYmUgaGFuZGxlZFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9ubWVzc2FnZSA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbm9wZW4gPSBudWxsXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25jbG9zZSA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbmVycm9yID0gbnVsbFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCBkZXN0cnVjdGlvbiB0byBiZSBoYW5kbGVkXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub250cmFjayA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BjID0gbnVsbFxuICAgICAgdGhpcy5fY2hhbm5lbCA9IG51bGxcblxuICAgICAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBfc2V0dXBEYXRhIChldmVudCkge1xuICAgIGlmICghZXZlbnQuY2hhbm5lbCkge1xuICAgICAgLy8gSW4gc29tZSBzaXR1YXRpb25zIGBwYy5jcmVhdGVEYXRhQ2hhbm5lbCgpYCByZXR1cm5zIGB1bmRlZmluZWRgIChpbiB3cnRjKSxcbiAgICAgIC8vIHdoaWNoIGlzIGludmFsaWQgYmVoYXZpb3IuIEhhbmRsZSBpdCBncmFjZWZ1bGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL2lzc3Vlcy8xNjNcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0RhdGEgY2hhbm5lbCBldmVudCBpcyBtaXNzaW5nIGBjaGFubmVsYCBwcm9wZXJ0eScpLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gICAgdGhpcy5fY2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IE1BWF9CVUZGRVJFRF9BTU9VTlRcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWxOYW1lID0gdGhpcy5fY2hhbm5lbC5sYWJlbFxuXG4gICAgdGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxNZXNzYWdlKGV2ZW50KVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9uYnVmZmVyZWRhbW91bnRsb3cgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsT3BlbigpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbENsb3NlKClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZXZlbnQuZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/IGV2ZW50LmVycm9yXG4gICAgICAgIDogbmV3IEVycm9yKGBEYXRhY2hhbm5lbCBlcnJvcjogJHtldmVudC5tZXNzYWdlfSAke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub306JHtldmVudC5jb2xub31gKVxuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cblxuICAgIC8vIEhBQ0s6IENocm9tZSB3aWxsIHNvbWV0aW1lcyBnZXQgc3R1Y2sgaW4gcmVhZHlTdGF0ZSBcImNsb3NpbmdcIiwgbGV0J3MgY2hlY2sgZm9yIHRoaXMgY29uZGl0aW9uXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG4gICAgbGV0IGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4geyAvLyBObyBcIm9uY2xvc2luZ1wiIGV2ZW50XG4gICAgICBpZiAodGhpcy5fY2hhbm5lbCAmJiB0aGlzLl9jaGFubmVsLnJlYWR5U3RhdGUgPT09ICdjbG9zaW5nJykge1xuICAgICAgICBpZiAoaXNDbG9zaW5nKSB0aGlzLl9vbkNoYW5uZWxDbG9zZSgpIC8vIGNsb3NpbmcgdGltZWQgb3V0OiBlcXVpdmFsZW50IHRvIG9uY2xvc2UgZmlyaW5nXG4gICAgICAgIGlzQ2xvc2luZyA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSwgQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQpXG4gIH1cblxuICBfcmVhZCAoKSB7fVxuXG4gIF93cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2VuZChjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBNQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgICAgdGhpcy5fY2IgPSBjYlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICAgIHRoaXMuX2NodW5rID0gY2h1bmtcbiAgICAgIHRoaXMuX2NiID0gY2JcbiAgICB9XG4gIH1cblxuICAvLyBXaGVuIHN0cmVhbSBmaW5pc2hlcyB3cml0aW5nLCBjbG9zZSBzb2NrZXQuIEhhbGYgb3BlbiBjb25uZWN0aW9ucyBhcmUgbm90XG4gIC8vIHN1cHBvcnRlZC5cbiAgX29uRmluaXNoICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgc29ja2V0IGZsdXNoZXMuXG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgY29uc3QgZGVzdHJveVNvb24gPSAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGVzdHJveSgpLCAxMDAwKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIGRlc3Ryb3lTb29uKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNlKCdjb25uZWN0JywgZGVzdHJveVNvb24pXG4gICAgfVxuICB9XG5cbiAgX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0ICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLl9pY2VDb21wbGV0ZVRpbWVyKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnc3RhcnRlZCBpY2VDb21wbGV0ZSB0aW1lb3V0JylcbiAgICB0aGlzLl9pY2VDb21wbGV0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2ljZUNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnaWNlQ29tcGxldGUgdGltZW91dCBjb21wbGV0ZWQnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ljZVRpbWVvdXQnKVxuICAgICAgICB0aGlzLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gICAgICB9XG4gICAgfSwgdGhpcy5pY2VDb21wbGV0ZVRpbWVvdXQpXG4gIH1cblxuICBfY3JlYXRlT2ZmZXIgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB0aGlzLl9wYy5jcmVhdGVPZmZlcih0aGlzLm9mZmVyT3B0aW9ucylcbiAgICAgIC50aGVuKG9mZmVyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWNrbGUgJiYgIXRoaXMuYWxsb3dIYWxmVHJpY2tsZSkgb2ZmZXIuc2RwID0gZmlsdGVyVHJpY2tsZShvZmZlci5zZHApXG4gICAgICAgIG9mZmVyLnNkcCA9IHRoaXMuc2RwVHJhbnNmb3JtKG9mZmVyLnNkcClcblxuICAgICAgICBjb25zdCBzZW5kT2ZmZXIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IG9mZmVyXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvblN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJ2NyZWF0ZU9mZmVyIHN1Y2Nlc3MnKVxuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMudHJpY2tsZSB8fCB0aGlzLl9pY2VDb21wbGV0ZSkgc2VuZE9mZmVyKClcbiAgICAgICAgICBlbHNlIHRoaXMub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZE9mZmVyKSAvLyB3YWl0IGZvciBjYW5kaWRhdGVzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKVxuICAgICAgICAgIC50aGVuKG9uU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2gob25FcnJvcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0NSRUFURV9PRkZFUicpKVxuICAgICAgfSlcbiAgfVxuXG4gIF9yZXF1ZXN0TWlzc2luZ1RyYW5zY2VpdmVycyAoKSB7XG4gICAgaWYgKHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycykge1xuICAgICAgdGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaCh0cmFuc2NlaXZlciA9PiB7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIubWlkICYmIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJiAhdHJhbnNjZWl2ZXIucmVxdWVzdGVkKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVxdWVzdGVkID0gdHJ1ZSAvLyBIQUNLOiBTYWZhcmkgcmV0dXJucyBuZWdvdGlhdGVkIHRyYW5zY2VpdmVycyB3aXRoIGEgbnVsbCBtaWRcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVBbnN3ZXIgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIodGhpcy5hbnN3ZXJPcHRpb25zKVxuICAgICAgLnRoZW4oYW5zd2VyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWNrbGUgJiYgIXRoaXMuYWxsb3dIYWxmVHJpY2tsZSkgYW5zd2VyLnNkcCA9IGZpbHRlclRyaWNrbGUoYW5zd2VyLnNkcClcbiAgICAgICAgYW5zd2VyLnNkcCA9IHRoaXMuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApXG5cbiAgICAgICAgY29uc3Qgc2VuZEFuc3dlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgYW5zd2VyXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKCF0aGlzLmluaXRpYXRvcikgdGhpcy5fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb25TdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMudHJpY2tsZSB8fCB0aGlzLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgICAgICAgZWxzZSB0aGlzLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRBbnN3ZXIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcilcbiAgICAgICAgICAudGhlbihvblN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKG9uRXJyb3IpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9DUkVBVEVfQU5TV0VSJykpXG4gICAgICB9KVxuICB9XG5cbiAgX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkLicpLCAnRVJSX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICAgIH1cbiAgfVxuXG4gIF9vbkljZVN0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGNvbnN0IGljZUNvbm5lY3Rpb25TdGF0ZSA9IHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZVxuICAgIGNvbnN0IGljZUdhdGhlcmluZ1N0YXRlID0gdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGVcblxuICAgIHRoaXMuX2RlYnVnKFxuICAgICAgJ2ljZVN0YXRlQ2hhbmdlIChjb25uZWN0aW9uOiAlcykgKGdhdGhlcmluZzogJXMpJyxcbiAgICAgIGljZUNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgIGljZUdhdGhlcmluZ1N0YXRlXG4gICAgKVxuICAgIHRoaXMuZW1pdCgnaWNlU3RhdGVDaGFuZ2UnLCBpY2VDb25uZWN0aW9uU3RhdGUsIGljZUdhdGhlcmluZ1N0YXRlKVxuXG4gICAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgICAgdGhpcy5fcGNSZWFkeSA9IHRydWVcbiAgICAgIHRoaXMuX21heWJlUmVhZHkoKVxuICAgIH1cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdJY2UgY29ubmVjdGlvbiBmYWlsZWQuJyksICdFUlJfSUNFX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICAgIH1cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdJY2UgY29ubmVjdGlvbiBjbG9zZWQuJyksICdFUlJfSUNFX0NPTk5FQ1RJT05fQ0xPU0VEJykpXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdHMgKGNiKSB7XG4gICAgLy8gc3RhdHJlcG9ydHMgY2FuIGNvbWUgd2l0aCBhIHZhbHVlIGFycmF5IGluc3RlYWQgb2YgcHJvcGVydGllc1xuICAgIGNvbnN0IGZsYXR0ZW5WYWx1ZXMgPSByZXBvcnQgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXBvcnQudmFsdWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXBvcnQudmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVwb3J0LCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBvcnRcbiAgICB9XG5cbiAgICAvLyBQcm9taXNlLWJhc2VkIGdldFN0YXRzKCkgKHN0YW5kYXJkKVxuICAgIGlmICh0aGlzLl9wYy5nZXRTdGF0cy5sZW5ndGggPT09IDAgfHwgdGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0Yykge1xuICAgICAgdGhpcy5fcGMuZ2V0U3RhdHMoKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcG9ydHMgPSBbXVxuICAgICAgICAgIHJlcy5mb3JFYWNoKHJlcG9ydCA9PiB7XG4gICAgICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY2IobnVsbCwgcmVwb3J0cylcbiAgICAgICAgfSwgZXJyID0+IGNiKGVycikpXG5cbiAgICAvLyBTaW5nbGUtcGFyYW1ldGVyIGNhbGxiYWNrLWJhc2VkIGdldFN0YXRzKCkgKG5vbi1zdGFuZGFyZClcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BjLmdldFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3BjLmdldFN0YXRzKHJlcyA9PiB7XG4gICAgICAgIC8vIElmIHdlIGRlc3Ryb3kgY29ubmVjdGlvbiBpbiBgY29ubmVjdGAgY2FsbGJhY2sgdGhpcyBjb2RlIG1pZ2h0IGhhcHBlbiB0byBydW4gd2hlbiBhY3R1YWwgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHJlcG9ydHMgPSBbXVxuICAgICAgICByZXMucmVzdWx0KCkuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHt9XG4gICAgICAgICAgcmVzdWx0Lm5hbWVzKCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtuYW1lXSA9IHJlc3VsdC5zdGF0KG5hbWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXBvcnQuaWQgPSByZXN1bHQuaWRcbiAgICAgICAgICByZXBvcnQudHlwZSA9IHJlc3VsdC50eXBlXG4gICAgICAgICAgcmVwb3J0LnRpbWVzdGFtcCA9IHJlc3VsdC50aW1lc3RhbXBcbiAgICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgICB9KVxuICAgICAgICBjYihudWxsLCByZXBvcnRzKVxuICAgICAgfSwgZXJyID0+IGNiKGVycikpXG5cbiAgICAvLyBVbmtub3duIGJyb3dzZXIsIHNraXAgZ2V0U3RhdHMoKSBzaW5jZSBpdCdzIGFueW9uZSdzIGd1ZXNzIHdoaWNoIHN0eWxlIG9mXG4gICAgLy8gZ2V0U3RhdHMoKSB0aGV5IGltcGxlbWVudC5cbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgW10pXG4gICAgfVxuICB9XG5cbiAgX21heWJlUmVhZHkgKCkge1xuICAgIHRoaXMuX2RlYnVnKCdtYXliZVJlYWR5IHBjICVzIGNoYW5uZWwgJXMnLCB0aGlzLl9wY1JlYWR5LCB0aGlzLl9jaGFubmVsUmVhZHkpXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCB8fCB0aGlzLl9jb25uZWN0aW5nIHx8ICF0aGlzLl9wY1JlYWR5IHx8ICF0aGlzLl9jaGFubmVsUmVhZHkpIHJldHVyblxuXG4gICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWVcblxuICAgIC8vIEhBQ0s6IFdlIGNhbid0IHJlbHkgb24gb3JkZXIgaGVyZSwgZm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcy1wbGF0Zm9ybS9ub2RlLXdlYnJ0Yy9pc3N1ZXMvMzM5XG4gICAgY29uc3QgZmluZENhbmRpZGF0ZVBhaXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICB0aGlzLmdldFN0YXRzKChlcnIsIGl0ZW1zKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgLy8gVHJlYXQgZ2V0U3RhdHMgZXJyb3IgYXMgbm9uLWZhdGFsLiBJdCdzIG5vdCBlc3NlbnRpYWwuXG4gICAgICAgIGlmIChlcnIpIGl0ZW1zID0gW11cblxuICAgICAgICBjb25zdCByZW1vdGVDYW5kaWRhdGVzID0ge31cbiAgICAgICAgY29uc3QgbG9jYWxDYW5kaWRhdGVzID0ge31cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlUGFpcnMgPSB7fVxuICAgICAgICBsZXQgZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSBmYWxzZVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgLy8gVE9ETzogT25jZSBhbGwgYnJvd3NlcnMgc3VwcG9ydCB0aGUgaHlwaGVuYXRlZCBzdGF0cyByZXBvcnQgdHlwZXMsIHJlbW92ZVxuICAgICAgICAgIC8vIHRoZSBub24taHlwZW5hdGVkIG9uZXNcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAncmVtb3RlY2FuZGlkYXRlJyB8fCBpdGVtLnR5cGUgPT09ICdyZW1vdGUtY2FuZGlkYXRlJykge1xuICAgICAgICAgICAgcmVtb3RlQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2xvY2FsY2FuZGlkYXRlJyB8fCBpdGVtLnR5cGUgPT09ICdsb2NhbC1jYW5kaWRhdGUnKSB7XG4gICAgICAgICAgICBsb2NhbENhbmRpZGF0ZXNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGVwYWlyJyB8fCBpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIgPT4ge1xuICAgICAgICAgIGZvdW5kU2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0gdHJ1ZVxuXG4gICAgICAgICAgbGV0IGxvY2FsID0gbG9jYWxDYW5kaWRhdGVzW3NlbGVjdGVkQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZUlkXVxuXG4gICAgICAgICAgaWYgKGxvY2FsICYmIChsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gU3BlY1xuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0KVxuICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWwgJiYgbG9jYWwuaXBBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwQWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWwucG9ydE51bWJlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ0xvY2FsQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIDU4IGlzIHJlbGVhc2VkXG4gICAgICAgICAgICBsb2NhbCA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nTG9jYWxBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gbG9jYWxbMF1cbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsWzFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxGYW1pbHkgPSB0aGlzLmxvY2FsQWRkcmVzcy5pbmNsdWRlcygnOicpID8gJ0lQdjYnIDogJ0lQdjQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHJlbW90ZSA9IHJlbW90ZUNhbmRpZGF0ZXNbc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLnJlbW90ZUNhbmRpZGF0ZUlkXVxuXG4gICAgICAgICAgaWYgKHJlbW90ZSAmJiAocmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gU3BlY1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnQpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZW1vdGUgJiYgcmVtb3RlLmlwQWRkcmVzcykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwQWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZS5wb3J0TnVtYmVyKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIDU4IGlzIHJlbGVhc2VkXG4gICAgICAgICAgICByZW1vdGUgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlWzBdXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlWzFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUZhbWlseSA9IHRoaXMucmVtb3RlQWRkcmVzcy5pbmNsdWRlcygnOicpID8gJ0lQdjYnIDogJ0lQdjQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAnY29ubmVjdCBsb2NhbDogJXM6JXMgcmVtb3RlOiAlczolcycsXG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0LFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAvLyBTcGVjLWNvbXBsaWFudFxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICd0cmFuc3BvcnQnICYmIGl0ZW0uc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihjYW5kaWRhdGVQYWlyc1tpdGVtLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbGQgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGl0ZW0udHlwZSA9PT0gJ2dvb2dDYW5kaWRhdGVQYWlyJyAmJiBpdGVtLmdvb2dBY3RpdmVDb25uZWN0aW9uID09PSAndHJ1ZScpIHx8XG4gICAgICAgICAgICAoKGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZXBhaXInIHx8IGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJykgJiYgaXRlbS5zZWxlY3RlZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBJZ25vcmUgY2FuZGlkYXRlIHBhaXIgc2VsZWN0aW9uIGluIGJyb3dzZXJzIGxpa2UgU2FmYXJpIDExIHRoYXQgZG8gbm90IGhhdmUgYW55IGxvY2FsIG9yIHJlbW90ZSBjYW5kaWRhdGVzXG4gICAgICAgIC8vIEJ1dCB3YWl0IHVudGlsIGF0IGxlYXN0IDEgY2FuZGlkYXRlIHBhaXIgaXMgYXZhaWxhYmxlXG4gICAgICAgIGlmICghZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgJiYgKCFPYmplY3Qua2V5cyhjYW5kaWRhdGVQYWlycykubGVuZ3RoIHx8IE9iamVjdC5rZXlzKGxvY2FsQ2FuZGlkYXRlcykubGVuZ3RoKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZmluZENhbmRpZGF0ZVBhaXIsIDEwMClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2h1bmspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKHRoaXMuX2NodW5rKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NlbnQgY2h1bmsgZnJvbSBcIndyaXRlIGJlZm9yZSBjb25uZWN0XCInKVxuXG4gICAgICAgICAgY29uc3QgY2IgPSB0aGlzLl9jYlxuICAgICAgICAgIHRoaXMuX2NiID0gbnVsbFxuICAgICAgICAgIGNiKG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGRgIGFuZCAnb25idWZmZXJlZGFtb3VudGxvdycgYXJlIHVuc3VwcG9ydGVkLFxuICAgICAgICAvLyBmYWxsYmFjayB0byB1c2luZyBzZXRJbnRlcnZhbCB0byBpbXBsZW1lbnQgYmFja3ByZXNzdXJlLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9vbkludGVydmFsKCksIDE1MClcbiAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWwudW5yZWYpIHRoaXMuX2ludGVydmFsLnVucmVmKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKCdjb25uZWN0JylcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JylcbiAgICAgIH0pXG4gICAgfVxuICAgIGZpbmRDYW5kaWRhdGVQYWlyKClcbiAgfVxuXG4gIF9vbkludGVydmFsICgpIHtcbiAgICBpZiAoIXRoaXMuX2NiIHx8ICF0aGlzLl9jaGFubmVsIHx8IHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBNQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKVxuICB9XG5cbiAgX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gZmFsc2VcblxuICAgICAgLy8gSEFDSzogRmlyZWZveCBkb2Vzbid0IHlldCBzdXBwb3J0IHJlbW92aW5nIHRyYWNrcyB3aGVuIHNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJ1xuICAgICAgdGhpcy5fZGVidWcoJ2ZsdXNoaW5nIHNlbmRlciBxdWV1ZScsIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSlcbiAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHNlbmRlcilcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICB9KVxuICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlID0gW11cblxuICAgICAgaWYgKHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdmbHVzaGluZyBuZWdvdGlhdGlvbiBxdWV1ZScpXG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpIC8vIG5lZ290aWF0ZSBhZ2FpblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ25lZ290aWF0ZWQnKVxuICAgICAgICB0aGlzLmVtaXQoJ25lZ290aWF0ZWQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCdzaWduYWxpbmdTdGF0ZUNoYW5nZSAlcycsIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICAgIHRoaXMuZW1pdCgnc2lnbmFsaW5nU3RhdGVDaGFuZ2UnLCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSlcbiAgfVxuXG4gIF9vbkljZUNhbmRpZGF0ZSAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmIChldmVudC5jYW5kaWRhdGUgJiYgdGhpcy50cmlja2xlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogJ2NhbmRpZGF0ZScsXG4gICAgICAgIGNhbmRpZGF0ZToge1xuICAgICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICBzZHBNaWQ6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNaWRcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFldmVudC5jYW5kaWRhdGUgJiYgIXRoaXMuX2ljZUNvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnX2ljZUNvbXBsZXRlJylcbiAgICB9XG4gICAgLy8gYXMgc29vbiBhcyB3ZSd2ZSByZWNlaXZlZCBvbmUgdmFsaWQgY2FuZGlkYXRlIHN0YXJ0IHRpbWVvdXRcbiAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICB0aGlzLl9zdGFydEljZUNvbXBsZXRlVGltZW91dCgpXG4gICAgfVxuICB9XG5cbiAgX29uQ2hhbm5lbE1lc3NhZ2UgKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBsZXQgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIF9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdyAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICF0aGlzLl9jYikgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ2VuZGluZyBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NiXG4gICAgdGhpcy5fY2IgPSBudWxsXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9vbkNoYW5uZWxPcGVuICgpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnb24gY2hhbm5lbCBvcGVuJylcbiAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSB0cnVlXG4gICAgdGhpcy5fbWF5YmVSZWFkeSgpXG4gIH1cblxuICBfb25DaGFubmVsQ2xvc2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ29uIGNoYW5uZWwgY2xvc2UnKVxuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cblxuICBfb25UcmFjayAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgZXZlbnQuc3RyZWFtcy5mb3JFYWNoKGV2ZW50U3RyZWFtID0+IHtcbiAgICAgIHRoaXMuX2RlYnVnKCdvbiB0cmFjaycpXG4gICAgICB0aGlzLmVtaXQoJ3RyYWNrJywgZXZlbnQudHJhY2ssIGV2ZW50U3RyZWFtKVxuXG4gICAgICB0aGlzLl9yZW1vdGVUcmFja3MucHVzaCh7XG4gICAgICAgIHRyYWNrOiBldmVudC50cmFjayxcbiAgICAgICAgc3RyZWFtOiBldmVudFN0cmVhbVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuc29tZShyZW1vdGVTdHJlYW0gPT4ge1xuICAgICAgICByZXR1cm4gcmVtb3RlU3RyZWFtLmlkID09PSBldmVudFN0cmVhbS5pZFxuICAgICAgfSkpIHJldHVybiAvLyBPbmx5IGZpcmUgb25lICdzdHJlYW0nIGV2ZW50LCBldmVuIHRob3VnaCB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgdHJhY2tzIHBlciBzdHJlYW1cblxuICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKGV2ZW50U3RyZWFtKVxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnb24gc3RyZWFtJylcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW0nLCBldmVudFN0cmVhbSkgLy8gZW5zdXJlIGFsbCB0cmFja3MgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfZGVidWcgKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICBhcmdzWzBdID0gJ1snICsgdGhpcy5faWQgKyAnXSAnICsgYXJnc1swXVxuICAgIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH1cbn1cblxuUGVlci5XRUJSVENfU1VQUE9SVCA9ICEhZ2V0QnJvd3NlclJUQygpXG5cbi8qKlxuICogRXhwb3NlIHBlZXIgYW5kIGRhdGEgY2hhbm5lbCBjb25maWcgZm9yIG92ZXJyaWRpbmcgYWxsIFBlZXJcbiAqIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBqdXN0IHNldCBvcHRzLmNvbmZpZyBvciBvcHRzLmNoYW5uZWxDb25maWdcbiAqIHdoZW4gY29uc3RydWN0aW5nIGEgUGVlci5cbiAqL1xuUGVlci5jb25maWcgPSB7XG4gIGljZVNlcnZlcnM6IFtcbiAgICB7XG4gICAgICB1cmxzOiBbXG4gICAgICAgICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyxcbiAgICAgICAgJ3N0dW46Z2xvYmFsLnN0dW4udHdpbGlvLmNvbTozNDc4J1xuICAgICAgXVxuICAgIH1cbiAgXSxcbiAgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJ1xufVxuXG5QZWVyLmNoYW5uZWxDb25maWcgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJcbiJdLCJuYW1lcyI6WyJkZWJ1ZyIsInJlcXVpcmUiLCJnZXRCcm93c2VyUlRDIiwicmFuZG9tYnl0ZXMiLCJzdHJlYW0iLCJxdWV1ZU1pY3JvdGFzayIsImVyckNvZGUiLCJCdWZmZXIiLCJNQVhfQlVGRkVSRURfQU1PVU5UIiwiSUNFQ09NUExFVEVfVElNRU9VVCIsIkNIQU5ORUxfQ0xPU0lOR19USU1FT1VUIiwiZmlsdGVyVHJpY2tsZSIsInNkcCIsInJlcGxhY2UiLCJ3YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJQZWVyIiwiRHVwbGV4IiwiY29uc3RydWN0b3IiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWxsb3dIYWxmT3BlbiIsIl9pZCIsInRvU3RyaW5nIiwic2xpY2UiLCJfZGVidWciLCJjaGFubmVsTmFtZSIsImluaXRpYXRvciIsImNoYW5uZWxDb25maWciLCJjaGFubmVsTmVnb3RpYXRlZCIsIm5lZ290aWF0ZWQiLCJjb25maWciLCJvZmZlck9wdGlvbnMiLCJhbnN3ZXJPcHRpb25zIiwic2RwVHJhbnNmb3JtIiwic3RyZWFtcyIsInRyaWNrbGUiLCJ1bmRlZmluZWQiLCJhbGxvd0hhbGZUcmlja2xlIiwiaWNlQ29tcGxldGVUaW1lb3V0IiwiZGVzdHJveWVkIiwiZGVzdHJveWluZyIsIl9jb25uZWN0ZWQiLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlRmFtaWx5IiwicmVtb3RlUG9ydCIsImxvY2FsQWRkcmVzcyIsImxvY2FsRmFtaWx5IiwibG9jYWxQb3J0IiwiX3dydGMiLCJ3cnRjIiwiRXJyb3IiLCJfcGNSZWFkeSIsIl9jaGFubmVsUmVhZHkiLCJfaWNlQ29tcGxldGUiLCJfaWNlQ29tcGxldGVUaW1lciIsIl9jaGFubmVsIiwiX3BlbmRpbmdDYW5kaWRhdGVzIiwiX2lzTmVnb3RpYXRpbmciLCJfZmlyc3ROZWdvdGlhdGlvbiIsIl9iYXRjaGVkTmVnb3RpYXRpb24iLCJfcXVldWVkTmVnb3RpYXRpb24iLCJfc2VuZGVyc0F3YWl0aW5nU3RhYmxlIiwiX3NlbmRlck1hcCIsIk1hcCIsIl9jbG9zaW5nSW50ZXJ2YWwiLCJfcmVtb3RlVHJhY2tzIiwiX3JlbW90ZVN0cmVhbXMiLCJfY2h1bmsiLCJfY2IiLCJfaW50ZXJ2YWwiLCJfcGMiLCJSVENQZWVyQ29ubmVjdGlvbiIsImVyciIsImRlc3Ryb3kiLCJfaXNSZWFjdE5hdGl2ZVdlYnJ0YyIsIl9wZWVyQ29ubmVjdGlvbklkIiwib25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJfb25JY2VTdGF0ZUNoYW5nZSIsIm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UiLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UiLCJfb25TaWduYWxpbmdTdGF0ZUNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwiZXZlbnQiLCJfb25JY2VDYW5kaWRhdGUiLCJwZWVySWRlbnRpdHkiLCJjYXRjaCIsIl9zZXR1cERhdGEiLCJjaGFubmVsIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJvbmRhdGFjaGFubmVsIiwiZm9yRWFjaCIsImFkZFN0cmVhbSIsIm9udHJhY2siLCJfb25UcmFjayIsIl9uZWVkc05lZ290aWF0aW9uIiwiX29uRmluaXNoQm91bmQiLCJfb25GaW5pc2giLCJvbmNlIiwiYnVmZmVyU2l6ZSIsImJ1ZmZlcmVkQW1vdW50IiwiY29ubmVjdGVkIiwicmVhZHlTdGF0ZSIsImFkZHJlc3MiLCJwb3J0IiwiZmFtaWx5Iiwic2lnbmFsIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsInJlbmVnb3RpYXRlIiwidHJhbnNjZWl2ZXJSZXF1ZXN0IiwiYWRkVHJhbnNjZWl2ZXIiLCJraW5kIiwiaW5pdCIsImNhbmRpZGF0ZSIsInJlbW90ZURlc2NyaXB0aW9uIiwidHlwZSIsIl9hZGRJY2VDYW5kaWRhdGUiLCJwdXNoIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJ0aGVuIiwiX2NyZWF0ZUFuc3dlciIsImljZUNhbmRpZGF0ZU9iaiIsIlJUQ0ljZUNhbmRpZGF0ZSIsImFkZEljZUNhbmRpZGF0ZSIsImVuZHNXaXRoIiwic2VuZCIsImNodW5rIiwiZW1pdCIsImdldFRyYWNrcyIsInRyYWNrIiwiYWRkVHJhY2siLCJzdWJtYXAiLCJnZXQiLCJzZW5kZXIiLCJzZXQiLCJyZW1vdmVkIiwicmVwbGFjZVRyYWNrIiwib2xkVHJhY2siLCJuZXdUcmFjayIsInJlbW92ZVRyYWNrIiwibmFtZSIsInJlbW92ZVN0cmVhbSIsIm5lZ290aWF0ZSIsInNldFRpbWVvdXQiLCJfY3JlYXRlT2ZmZXIiLCJfZGVzdHJveSIsImNiIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kZWQiLCJfd3JpdGFibGVTdGF0ZSIsImZpbmlzaGVkIiwiZW5kIiwiY2xlYXJJbnRlcnZhbCIsInJlbW92ZUxpc3RlbmVyIiwiY2xvc2UiLCJvbm1lc3NhZ2UiLCJvbm9wZW4iLCJvbmNsb3NlIiwib25lcnJvciIsImJpbmFyeVR5cGUiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImxhYmVsIiwiX29uQ2hhbm5lbE1lc3NhZ2UiLCJvbmJ1ZmZlcmVkYW1vdW50bG93IiwiX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93IiwiX29uQ2hhbm5lbE9wZW4iLCJfb25DaGFubmVsQ2xvc2UiLCJlcnJvciIsImZpbGVuYW1lIiwibGluZW5vIiwiY29sbm8iLCJpc0Nsb3NpbmciLCJzZXRJbnRlcnZhbCIsIl9yZWFkIiwiX3dyaXRlIiwiZW5jb2RpbmciLCJkZXN0cm95U29vbiIsIl9zdGFydEljZUNvbXBsZXRlVGltZW91dCIsImNyZWF0ZU9mZmVyIiwib2ZmZXIiLCJzZW5kT2ZmZXIiLCJsb2NhbERlc2NyaXB0aW9uIiwib25TdWNjZXNzIiwib25FcnJvciIsInNldExvY2FsRGVzY3JpcHRpb24iLCJfcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMiLCJnZXRUcmFuc2NlaXZlcnMiLCJ0cmFuc2NlaXZlciIsIm1pZCIsInJlcXVlc3RlZCIsImNyZWF0ZUFuc3dlciIsImFuc3dlciIsInNlbmRBbnN3ZXIiLCJjb25uZWN0aW9uU3RhdGUiLCJpY2VDb25uZWN0aW9uU3RhdGUiLCJpY2VHYXRoZXJpbmdTdGF0ZSIsIl9tYXliZVJlYWR5IiwiZ2V0U3RhdHMiLCJmbGF0dGVuVmFsdWVzIiwicmVwb3J0IiwicHJvdG90eXBlIiwiY2FsbCIsInZhbHVlcyIsInZhbHVlIiwibGVuZ3RoIiwicmVzIiwicmVwb3J0cyIsInJlc3VsdCIsIm5hbWVzIiwic3RhdCIsImlkIiwidGltZXN0YW1wIiwiX2Nvbm5lY3RpbmciLCJmaW5kQ2FuZGlkYXRlUGFpciIsIml0ZW1zIiwicmVtb3RlQ2FuZGlkYXRlcyIsImxvY2FsQ2FuZGlkYXRlcyIsImNhbmRpZGF0ZVBhaXJzIiwiZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIiLCJpdGVtIiwic2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlyIiwibG9jYWwiLCJsb2NhbENhbmRpZGF0ZUlkIiwiaXAiLCJOdW1iZXIiLCJpcEFkZHJlc3MiLCJwb3J0TnVtYmVyIiwiZ29vZ0xvY2FsQWRkcmVzcyIsInNwbGl0IiwiaW5jbHVkZXMiLCJyZW1vdGUiLCJyZW1vdGVDYW5kaWRhdGVJZCIsImdvb2dSZW1vdGVBZGRyZXNzIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJnb29nQWN0aXZlQ29ubmVjdGlvbiIsInNlbGVjdGVkIiwia2V5cyIsIl9vbkludGVydmFsIiwidW5yZWYiLCJzaWduYWxpbmdTdGF0ZSIsInNkcE1MaW5lSW5kZXgiLCJzZHBNaWQiLCJBcnJheUJ1ZmZlciIsImZyb20iLCJldmVudFN0cmVhbSIsInNvbWUiLCJyZW1vdGVTdHJlYW0iLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJXRUJSVENfU1VQUE9SVCIsImljZVNlcnZlcnMiLCJ1cmxzIiwic2RwU2VtYW50aWNzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/simple-peer/index.js\n");

/***/ })

};
;